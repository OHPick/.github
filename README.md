# ![로고](https://github.com/ShareOffice-11/OHPickOfficial/assets/83201893/064c9d75-fbd9-40b2-867c-a31359cfc231) PROJECT 소개

![브로셔메인](https://github.com/ShareOffice-11/OHPickOfficial/assets/83201893/cfc3c265-097b-44e4-85bf-d4250a1c1d47)

> ✨ 기술 스택 : `React` `Spring` <br>
> 
> 🚩 개발 기간 : 2023.05.23 ~ 2023.06.29 <br>
>
> ➡️ URL : https://ohpick.shop/

<br>

<br>

## ![로고](https://github.com/ShareOffice-11/OHPickOfficial/assets/83201893/064c9d75-fbd9-40b2-867c-a31359cfc231) 서비스 소개 <br>


    📢  저희 'OhPick'은 우리만의 오피스 공간이 필요하신 분들을 위해 개인이 가진 공간을 오피스 공간으로 
        공유, 대여할 수 있도록 중개하는 서비스입니다.
        
        개인 작업실부터 큰 규모의 팀 공간까지 다양한 유형의 오피스 정보를 제공해 드립니다. 
        간편한 지역 검색 및 필터링 기능으로 원하는 조건에 맞는 오피스를 손쉽게 찾을 수 있을 뿐만 아니라
        간편 예약 서비스까지 제공하여 고객이 원하는 날짜에 빠른 예약이 가능하도록 설계하였습니다.


<br>

<br>

## ![로고](https://github.com/ShareOffice-11/OHPickOfficial/assets/83201893/064c9d75-fbd9-40b2-867c-a31359cfc231) 아키텍처 구성도 <br>

![아키텍처 구성도](https://github.com/ShareOffice-11/OHPickOfficial/assets/83201893/13250ebe-c18e-4b8e-a9bd-30b91f8f2eab)


<br>

<br>


## ![로고](https://github.com/ShareOffice-11/OHPickOfficial/assets/83201893/064c9d75-fbd9-40b2-867c-a31359cfc231) 주요 기능 <br>


<details>
  <summary> 1️⃣ 게시글 CRUD 기능 (포스트 작성, 조회, 수정, 삭제) </summary>
  
</details>
<details>
  <summary> 2️⃣ 예약 및 채팅 기능 </summary>
  
</details>
<details>
  <summary> 3️⃣ 키워드 / 지역 별 검색 및 로그인, 회원가입 기능 </summary>
  
</details>
<details>
  <summary> 4️⃣ 마이페이지 (글 목록 조회, 로그아웃 및 회원 탈퇴) 기능 </summary>
  
</details>

<br>

<br>



## ![로고](https://github.com/ShareOffice-11/OHPickOfficial/assets/83201893/064c9d75-fbd9-40b2-867c-a31359cfc231) 기술적 의사 결정 <br>

### 👥 FRONT-END

<details>
  <summary> <b>Reac-Query</b> </summary>
    
<br>

|  **도입 이유** | react-query를 사용해 서버 상태를 관리하여 캐싱 처리로 속도와 성능을 개선 하기 위해 도입하였습니다.  |
|:--------:|:---|
| **문제 상황** | 저희 OHPick서비스는 사용자들에게 많은 오피스 데이터들을 쾌적하게 제공해야 합니다. 특히 주요 기능인 오피스 검색(무한스크롤), 채팅 등에서 사용자의 검색 필터링에 따라 수시로 데이터 결과 값이 변경되어야 합니다. 많은 데이터가 수시로 변경되는 부분에 있어 속도와 성능 관련하여 문제가 있을 수 있다고 판단하여 성능적인 측면에서 캐싱 처리를 고민했습니다. |
| **해결 방안** | 1. Axios만을 이용한 데이터 통신 <br> 2. Axios와 React Query를 함께 사용하여 서버 상태 관리 |
| **의견 조율 및 의정** | ⇒ `성능을 위해 캐싱 기능에 대한 고려가 필요` <br> <br> 1. Axios는 HTTP 요청을 처리, 캐싱과 상태 관리는 지원하지 않음 <br> 2. 상태 관리와 캐싱이 필요할 경우 React-query와 함께 사용하는 것이 더 적합 <br> 3. 리액트 쿼리의 장점(최신 데이터 자동 동기화 기능, 캐싱, 서버 데이터 처리 로직 분리로 가독성 및 유지보수성 증가 등) <br> <br> react-query를 사용하게 되면 캐싱 데이터를 사용하여 중복되는 데이터 요청을 줄이고, 필요할 때에 캐싱된 데이터와 새로 업데이트 된 데이터를 새로 가져올 수도 있습니다. 이렇게 캐싱 처리된 데이터를 사용하게 되면 사용자가 빠르게 데이터를 확인할 수 있기 때문에 사용자 경험성이 향상될 것으로 판단하여 react-query를 도입하였습니다. |
| **결과** | eact-query의 캐싱 기능으로 검색 속도와 불필요한 데이터 요청이 최적화되어 사용자 경험성이 증가하였습니다. 유저 테스트 결과 초기 로딩 및 검색 속도 문항에서 76.3%의 유저들이 ‘빠르다’라고 답하였습니다. |

<br>

</details>

<details>
  <summary> <b>Recoil</b> </summary>
    
<br>

|  **도입 이유** | 전역 상태 관리 라이브러리 중 React에 최적화 되어있고, 안정적인 recoil을  recoil을 사용하여 간편하게 로그인 전역 상태, 모달 상태, 검색 쿼리, 토글 등의 클라이언트 상태를 관리하기 위해 도입하였습니다.  |
|:---:|:---|
| **문제 상황** | 저희 OHPick서비스의 검색, 모달, 로그인 상태관리 등의 기능에서 클라이언트의 전역 상태 관리의 필요성을 느꼈습니다. 주요 데이터인 오피스 데이터들은 주로 서버 상태 관리로 이루어지기 때문에 그밖에 간단하고 가벼운 기능들을 편리하게 관리할 수 있는 전역 상태 관리 라이브러리가 필요했습니다. 기존에는 Redux 또는 useContext를 사용하였었으나 단지 전역 상태를 관리하는 데에 너무 불필요하게 복잡한 과정을 거쳐야 하고, Boiler Plate 초기 세팅이 요구되는 등의 문제가 있어 더 편리하고 가벼운 라이브러리가 필요했습니다. |
| **해결 방안** | 1. Redux로 관리 <br> 2. useContext로 전역 관리 <br> 3. Recoil로 관리 |
| **의견 조율 및 의정** |전역 상태 라이브러리를 사용하기 전, React 자체에서 제공하는 Hook의 useContext를 이용해 전역 상태를 관리해 보았습니다. 하지만  useContext를 사용해 보니 Redux보다 크게 간단 하다거나 편리하다는 느낌을 받지 못했습니다. 추후 recoil을 도입해 리팩토링 해보니 recoil이 리액트에 최적화 되어 안정성도 높고, 코드도 줄어 가장 관리가 쉽고 편리하게 전역 상태를 관리할 수 있다고 생각되어 recoil을 사용하는 것으로 결정하였습니다. |

<br>
  
</details>


<details>
  <summary> <b>ESLint(airBnB) + Prettier</b> </summary>
    
<br>

|  **도입 이유** | ESLint(airBnB)와 Prettier로 컨벤션을 강제(에러), 강제한 컨벤션 규칙에 맞게 Prettier에서 자동으로 교정해 주도록 설정하여 컨벤션에 맞춰 코드를 작성할 수 있도록 하기 위해 도입하였습니다.  |
|:---:|:---|
| **문제 상황** | 팀원과의 협업 과정 중에서 변수명, 함수명, api명 등 컨벤션적으로 맞지 않는 부분들이 발생하여 코드의 통일성, 가독성이 좋지 않고 혼란스러운 상황이 많이 발생 하였습니다. |
| **해결 방안** | 1. ESLint 기본설정과 Prettier를 사용해 컨벤션을 유지한다. <br> 2. ESLint airBnB와 Prettier를 사용해 좀 더 강력한 컨벤션을 강제하여 규칙을 준수하도록 한다. |
| **의견 조율 및 의정** |처음에는 기본적인 ESLint 설정으로만 진행하고자 하였으나, 그렇게 되면 강제성이 미약하여 코드의 통일성을 유지하고자 하는 목적성이 떨어진다고 판단하였고, 좀 더 강력한 airBnB스타일을 적용하게 되면 웹 접근성이나 검색 엔진 유입률까지 향상시킬 수 있다고 판단되어 ESLint(airBnB) + Prettier를 사용하기로 결정 하였습니다. |
| **결과** | ESLint(airBnB) + Prettier의 강제성 덕분에 적절한 태그 사용 및 라벨링으로 검색엔진 및 웹 접근성 점수가 향상되어 Light-house 측정 결과 웹 접근성, SEO에서 100점에 도달할 수 있었습니다. |

<br>
  
</details>

<details>
  <summary> <b>SCSS(Sassy CSS) + Tailwind</b> </summary>
    
<br>

| **도입 이유** | SCSS 전처리기를 이용해 변수, 함수, 문법 등을 이용해 CSS 코드를 좀 더 편리하게  사용하고 관리하기 위해 도입하였습니다.  |
|:---:|:---|
| **문제 상황** | 서비스가 복잡해짐에 따라 CSS파일들을 관리하는데 어려움을 느꼈고, 더 편리한 CSS문법을 사용해 중복되는 코드의 재사용성을 높이면서 유지 보수가 용이하게 하는 전처리기의 필요성을 느끼게 되었습니다. |
| **해결 방안** | 1. Redux로 관리 <br> 2. useContext로 전역 관리 <br> 3. Recoil로 관리 |
| **의견 조율 및 의정** |전역 상태 라이브러리를 사용하기 전, React 자체에서 제공하는 Hook의 useContext를 이용해 전역 상태를 관리해 보았습니다. 하지만  useContext를 사용해 보니 Redux보다 크게 간단 하다거나 편리하다는 느낌을 받지 못했습니다. 추후 recoil을 도입해 리팩토링 해보니 recoil이 리액트에 최적화 되어 안정성도 높고, 코드도 줄어 가장 관리가 쉽고 편리하게 전역 상태를 관리할 수 있다고 생각되어 recoil을 사용하는 것으로 결정하였습니다. |

<br>
  
</details>

    
<br>



### 👥 BACK-END

<details>
  <summary> <b>WebSocket Stomp</b> </summary>
    
<br>

|  **도입 이유** | 사용자들이 여러 게시물의 작성자들과 다른 내용의 채팅을 원활하게 할 수 있도록 하기 위해서 채팅 기능을 도입하였습니다.  |
|:--------:|:---|
| **문제 상황** | 저희 서비스의 주요 기능 중 하나인 게시글의 작성자와 소통을 하게 해주는 실시간 채팅 기능을 도입하기로 결정하였습니다. 이때 사용자는 여러 게시물의 작성자와 각기 다른 내용의 채팅이 실시간으로 가능해야 하기에, 여러 채팅 방에 접속이 가능해야 했는데, 이 기능을 어떻게 구현 할지 고민이 되었습니다.  |
| **해결 방안** | 1. http 방식을 사용해서 채팅 구현  <br> 2. WebSocket 방식을 사용하여 구현  |
| **의견 조율 및 의정** | => `서버 부담 가능성 및 기능 고려 필요` <br> <br> -> http 방식은 실시간 채팅을 위한 지속적인 서버와의 요청 및 응답이 필요 (서버 과부화 예상) <br> -> 반면 Websocket은 http 요청과 응답 한번으로 handshake 후, tcp 연결 유지하여 새로운 요청 없이도 데이터 전송 가능 <br>  <br> 처음에는 사용자가 실시간 채팅 기능을 사용할 때 지속해서 응답을 가져오기 위하여 계속 요청을 보내는 polling, long polling 방식 혹은 서버 측에서 응답(flush)을 지속 해서 보내주는 streaming 방식도 생각해 보았으나, 이런 방식들을 클라이언트가 많아 질 시, 혹은 채팅 메세지가 많아 질 시 서버에 부담이 가고 예상하지 못한 오류가 많았을 것이라고 판단이 되었습니다. 이로 인해, 실시간 채팅을 하여도 서버에 부담이 많이 안 가고 tcp연결을 통하여 요청과 응답의 오베허드를 줄여 데이터 전송의 효율성을 높여주는 Websocket을 사용하기로 결정하였습니다. 또한.  저희 서비스에 중요 기능 중 하나인 한 사용자가 여러 채팅 방에 접속이 되는 것을 가능케 해주는 WebSocket Stomp를 적용하기로 결정하였습니다. 이로 인해 서버 과부화 없이 여러 실시간 채팅 방 생성이 가능하였습니다.  |

<br>

</details>

<details>
  <summary> <b>QueryDSL</b> </summary>
    
<br>

|  **도입 이유** | 서비스의 주요 기능에 사용 될 복잡한 쿼리를 해결할 방법이 필요하여 도입하였습니다.  |
|:---:|:---|
| **문제 상황** | 저희 서비스의 키워드 검색, 필터링 검색, 및 채팅 방 리스트 불러오기 같은 주요 기능들을 구현하기 위해서는 복잡하지만, 알맞은 쿼리를 데이터베이스에 보내어서 필요한 데이터를 가져와야 했습니다. 이때 필요한 쿼리를 어떻게 작성 해야 할지 고민 되었습니다. |
| **해결 방안** | 1. 기본 JPA <br> 2. JPQL <br> 3. Query DSL |
| **의견 조율 및 의정** |처음에는 기본 JPA를 사용하여 여러 쿼리를 보내어서 작성하려 했으나 여러 쿼리 작성 방법에 대해 찾아보다가 여러 쿼리를 보내는 것이 하나의 쿼리를 보내는 것 보다 더 많은 시간이 걸린다고 하여서, 더 작은 수의 쿼리를 보내는 방법을 선택하기로 하였습니다. 이로 인해 JPQL도 고려해보았으나, 이는 compile 단계에서 에러 체크가 불가하기 때문에 java 코드로 쿼리를 작성하고, compile 단계에서 에러 체크가 가능한 QueryDSL을 사용하기로 결정하였습니다. |

<br>
  
</details>


<details>
  <summary> <b>CI/CD</b> </summary>
    
<br>

|  **도입 이유** | 프로젝트의 원활한 진행을 위해 배포가 자동으로 이루어져야 해서 도입하였습니다.   |
|:---:|:---|
| **문제 상황** | 백엔드 측 코드에 변경이 생길 때 마다 프로젝트 빌드 및 서버에 파일을 옮겨서 배포를 직접 해줘야 하는 상황이 반복적으로 발생함으로써 클라이언트에게 빠르게 코드를 반영해주기 어려웠습니다.  |
| **해결 방안** | 1. Jenkins <br> 2. Dockers <br> 3. Git Action  |
| **의견 조율 및 의정** | 처음에는 Jenkins, Docker도 생각해보았으나 별도의 서버 설치가 필요하기에 보다 적용하기 수월하고 쉽게 다룰 수 있는 Github Actions를 사용하기로 결정하였습니다. 또한, 다른 AWS 서비스와 관리 환경이 같은면서 통합적 지원이 잘 되고 안정적인 배포를 보장하는 AWS CodeDeploy를 사용하기로 결정하였습니다. |

<br>
  
</details>

<br>
  

<br>
  
## ![로고](https://github.com/ShareOffice-11/OHPickOfficial/assets/83201893/064c9d75-fbd9-40b2-867c-a31359cfc231) 트러블 슈팅 <br>

### 👥 FRONT-END

<details>
  <summary> <b>무한 스크롤 - useInfiniteQuery 도입</b> </summary>
    
<br>

`문제상황`

유저 피드백에서 ‘전체 조회 시 20개만 조회 할 수 있다. 더 많은 공간을 보고 싶다’는 피드백이 있어 무한 스크롤을 도입하게 되었습니다. 무한 스크롤을 도입하게 되면 아무래도 페이지 로딩 속도가 느려질 수 있기 때문에 성능 측면에서 캐싱 처리가 가능한 useQuery와 따로 throttle을 구현하지 않고도 이벤트 횟수를 줄일 수 있는 IntersectionObserver API로 무한 스크롤 기능을 구현 하였습니다. 하지만 한 번 스크롤 시 Observer 버튼이 계속해서 뷰 포트 상에 노출되어 계속해서 [ 옵저버 중복 실행 →  페이지 상태가 계속 증가 → 데이터 통신 ]이 계속되어 페이지가 늘어나는 현상이 발생했습니다. 

`해결 방안` 

1안 : Observer의 prevent상태를 관리하여 옵저버가 실행되어 true인 상태일 동안은 [ 옵저버 실행 → 페이지 증가 → 데이터 통신 ] 과정이 일어나지 않도록 직접 상태를 컨트롤 하여 중복 실행을 방지

2안 : useInfiniteQuery를 도입하여 페이지 상태 관리를 직접 하지 않고 fetchNextPage 함수를 이용하며, 옵저버는 isFetching(실행중)일 경우 발생하지 않도록 방지

`의견 조율` 

두 가지 방안으로 모두 개발하여 성능적으로 어떤 방안이 더 좋은지 테스트해 보았습니다.

1안일 경우 3가지의 문제가 있었습니다.

1. 추가 구현이 필요 하다 : Intersection Observer API는 교차 여부를 감지하는 기능만 제공하므로 데이터 페칭 및 상태 관리와 관련된 로직은 직접 구현해야 함.
2. 이렇게 무한 스크롤 페이지 및 데이터 상태를 직접 관리하다 보니 검색 상태와 더해져, 상태 관리에 의한 잦은 렌더링으로 성능의 문제 우려됨. 테스트 결과 0~ 6페이지 스크롤까지 평균 20번씩의 렌더링, 검색시에는 최고 40번까지 발생하는 경우도 있었음
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/47c248df-cd50-4df9-b4c8-050b3b4ff844/Untitled.png)
    
3. 간혹 연속으로 잦은 검색 시 로딩 스피너만 계속해서 돌아가는 등의 문제가  발생

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/77569a0e-35db-46fd-aa4a-8336e0a3da1c/Untitled.png)

2안일 경우 옵션 함수로 상태를 관리 해 주기 때문에 위의 모든 문제에 대해 자유로웠습니다. 하지만 useInfiniteQuery 자체적으로 초기 데이터 통신이 2번 더 발생하는 문제가 있었습니다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1faf9c2b-9ace-4748-867b-91fe7057a107/Untitled.png)

`의견 결정`

1. 1안은 직접 관리해줘야 할 상태가 최소 3~4개로 더 많기 때문에 0~ 6페이지까지 스크롤 하는데 렌더링이 평균 20회 ~ 검색 시에는 간혹 40회까지 발생했는데, 2안은 평균적으로 13회정도 발생하여 두 배 정도 차이가 났습니다. 
2. 또 간혹 발생하는 무한 로딩 스피너 등의 문제가 useInfiniteQuery에서는 발생하지 않았기 때문에 버그 이슈나 사용자 경험성에도 더 나을 것으로 판단하였습니다.
3. useInfiniteQuery를 사용할 경우 개발자가 직접 관리해야 할 로직과 상태 관리가 줄어들어 코드 관리나 유지 보수에도 용이하다고 판단하였습니다.

결과적으로 시간적 여유가 있고 좀 더 세분화하여 기능을 조작해야 할 경우는 직접 페이지 상태 관리와 옵저버 상태를 관리하는 것이 낫다고 판단되었고, 일반적인 경우에는 useInfiniteQuery의 이점이 더 많다고 판단되어 테스트 후 useInfiniteQuery를 사용하여 해결하였습니다.

<br>

</details>

<details>
  <summary> <b>이미지 수정 시 이미지 업로드 방식</b> </summary>
    
<br>

`문제 상황` 

저희 서비스에는 멀티 이미지 업로드가 가능한 글쓰기 기능이 개발되어 있었습니다. 글 수정 로직을 신규로 개발함에 있어 시간이 한정적인 상황에서 최대한 효율적인 방법으로 수정 로직을 구현하고자 하였습니다.

`해결 방안` 

1안 : 이미지 수정을 하는 경우와 아닌 경우를 나누어 요청하는 방법
(유저가 이미지를 바꾸는 경우에만 파일이 업로드 됨)

2안 : 기존 이미지 URL로 파일 객체를 받아와 유저의 동작과 관계 없이 항상 파일을 업로드 하는 방법 (항상 파일이 업로드 됨)

`의견 조율` 

1안을 선택하는 경우,

장점 : 많이 사용하는 방법
단점 : 업로드 유무만 나누는 것이 아니라 이미지 순서, 삭제 이미지의 정보 등을 추가로 보내야 해서 로직을 새로 짜야함 (개발시간↑ 로직의 재사용성↓)

2안을 선택하는 경우,

장점 : 항상 파일 객체를 보내기 때문에 로직의 수정이 많이 필요치 않음
(개발시간↓ 로직의 재사용성↑)
단점 : 동일 이미지의 계속적인 업로드로 서버의 자원 낭비 및 이미지 URL을 이용해 S3 버킷에서 직접 이미지 객체 다운로드 시 CORS 에러 발생

`의견 결정`

시간적 한계와 로직의 재사용성 등을 고려하여 최종적으로 2안을 택하였습니다.
그리고 2안이 가지고 있는 문제점을 다음과 같이 해결하였습니다.

1. 서버 자원 낭비
→ 수정 이미지 업로드 시 기존 글의 이미지를 모두 삭제 후 업로드 하는 방식으로 해결
2. CORS 에러
→ 브라우저가 로컬 캐시를 사용하고 있어서 CORS에러가 나고 있음을 확인하였고, 이 부분을 해결하기 위해 이미지 URL로 get 요청 시 headers에 no-cache 설정을 추가하여 해결

[ CORS 에러 해결 과정 ]

1. S3 CORS 정책 설정
→ S3의 경우 요청 헤더에 Origin이 없을 경우 CORS 응답헤더를 전달하지 않음
2. Origin 헤더를 직접 추가하여 요청
→ 브라우저가 로컬 캐시를 사용하고 있어 CORS 에러가 지속됨을 확인
3. 이미지 URL로 get 요청 시 headers에 no-cache 설정을 추가

```
const config = {
        headers: {
          'Content-Type': 'multipart/form-data',
          'Cache-Control': 'no-cache',
        },
        responseType: 'blob',
      };
```

<br>

</details>


<details>
  <summary> <b>로그인 상태 유지 - 브라우저에 재 접속 시 Recoil 로그인 전역 상태 초기화 문제</b> </summary>
    
<br>

`문제 상황` 

저희 서비스는 사용자의 번거로움을 줄이기 위해 이미 로그인한 사용자라면, 리프레쉬 토큰 만료 전 까지는 브라우저 종료 후 다시 들어와도 로그인 한 상태를 유지해야 합니다. 문제는 Recoil 전역 상태로 토큰을 확인해 로그인 여부를 관리하였는데 브라우저가 실행되면 항상 초기값으로 초기화되기 때문에 Recoil에서 관리하는 로그인 상태의 초기값이 false일 경우 브라우저에서 재 접속 시 초기화 되어 다시 로그인을 해야 하는 상황이 발생했습니다.

`해결 방안` 

1. 앱이 처음 mount 되자마자 useEffect를 사용해 토큰의 여부를 확인하여 로그인 상태를 업데이트 
2. 로그인 전역 상태의 초기값을 아예 토큰 여부를 확인한 isToken 변수로 설정

`의견 조율` 

usEffect를 사용하여 앱이 처음 mount 시 로그인 여부를 업데이트 시키게 되면, 처음 로드됐을 때 외에 새로고침 등 상태값이 초기화 되는 상황 마다 업데이트가 되도록 따로 설정해주어야 합니다. 상태값이 초기값으로 초기화될 때 아예 토큰 여부를 확인한 결과값으로 초기화되게 하면 초기화 되는 모든 상황에서도 항상 토큰여부를 확인하여 결과값으로 로그인 여부를 파악하고 유지할 수 있다고 판단하였습니다.

`의견 결정`

상태의 초기값을 isToken의 토큰 여부를 확인한 결과값으로 초기화되게 하여 전역 상태를 잃는 모든 상황에서도 로그인 여부를 확인하고 유지할 수 있도록 하였습니다.


<br>

</details>


<br>
  
### 👥 BACK-END

<details>
  <summary> <b>액세스 토큰, 리프레시 토큰 전송 방식 수정</b> </summary>
    
<br>

 `개선 전`
 
 
 JWT 액세스 토큰, 리프레시 토큰을 클라이언트에 보낼 때, response.addHeader 방식으로 보내고 있었는데, 이렇게 하니, 개발자 도구에서 document.cookie 를 하면, 토큰 값이 노출 되었습니다. 이로 인해, 보안 측에 문제가 있었습니다. 
 
 ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/59bea0b1-93ec-426d-8ef4-ec4cac3de427/Untitled.png)
 
 ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/17657bec-b981-4cd5-bb51-6839436c4f94/Untitled.png)
 
 `해결 방법`
 
 
 쿠키에 httpOnly 와 secure 가 적용되면 http 요청일 때만 쿠키 값이 접근이 되어서 document.cookie로 접근이 불가 합니다. 이를 통해 개선 전 문제가 해결되지만 액세스 토큰과 리프레시 토큰 전부를 쿠키로 전송하는 것은 CSRF 공격에 취약하기 때문에, 액세스 토큰을 재 발급 해주는 용도로만 사용되는 리프레시 토큰만 쿠키로 수정하였습니다. 
 
 ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a72d48e0-1d24-4086-a374-5dd982825ef5/Untitled.png)
 
 ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/cb8de8f7-5504-4b2e-9ffe-9b4d6d07072f/Untitled.png)
 
 그리고, 인증된 사용자인지 확인 해주는 액세스 토큰은 CSRF나 XSS 같은 보안 공격에 대응하기 위하여 클라이언트에서 private 변수 값으로 저장하는 방식을 선택하였습니다. 이를 가능케 할 수 있도록 response의 body 를 통해 전송하는 방식으로 수정하였습니다. 또한 액세스 토큰이 만료 될 때 마다, 쿠키에 담겨진 리프레시 토큰을 사용하여 재발급 해주는 api도 구성하였습니다. 
 
 ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e561f148-c9ae-4199-98c3-cc91666edd93/Untitled.png)
 
 ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/0b987344-445e-4516-ba0e-da398be49c08/Untitled.png)
 
 `개선 후 결과`
 
 
 변경 사항 적용 후, 사용자가 로그인 요청을 하였을 시, 액세스 토큰이 response의 body 값으로 들어오는 것을 확인 할 수 있었습니다. 또한, 개발자 도구로 document.cookie 를 하였더니, 쿠키로 수정된 리프레시 토큰 및 private 변수로 저장된 액세스 토큰 노출이 안되었습니다.  이로써 보안을 강화하였습니다. 


<br>

</details>

<details>
  <summary> <b>이미지 수정 시 이미지 업로드 방식</b> </summary>
    
<br>

`문제 상황` 

저희 서비스에는 멀티 이미지 업로드가 가능한 글쓰기 기능이 개발되어 있었습니다. 글 수정 로직을 신규로 개발함에 있어 시간이 한정적인 상황에서 최대한 효율적인 방법으로 수정 로직을 구현하고자 하였습니다.

`해결 방안` 

1안 : 이미지 수정을 하는 경우와 아닌 경우를 나누어 요청하는 방법
(유저가 이미지를 바꾸는 경우에만 파일이 업로드 됨)

2안 : 기존 이미지 URL로 파일 객체를 받아와 유저의 동작과 관계 없이 항상 파일을 업로드 하는 방법 (항상 파일이 업로드 됨)

`의견 조율` 

1안을 선택하는 경우,

장점 : 많이 사용하는 방법
단점 : 업로드 유무만 나누는 것이 아니라 이미지 순서, 삭제 이미지의 정보 등을 추가로 보내야 해서 로직을 새로 짜야함 (개발시간↑ 로직의 재사용성↓)

2안을 선택하는 경우,

장점 : 항상 파일 객체를 보내기 때문에 로직의 수정이 많이 필요치 않음
(개발시간↓ 로직의 재사용성↑)
단점 : 동일 이미지의 계속적인 업로드로 서버의 자원 낭비 및 이미지 URL을 이용해 S3 버킷에서 직접 이미지 객체 다운로드 시 CORS 에러 발생

`의견 결정`

시간적 한계와 로직의 재사용성 등을 고려하여 최종적으로 2안을 택하였습니다.
그리고 2안이 가지고 있는 문제점을 다음과 같이 해결하였습니다.

1. 서버 자원 낭비
→ 수정 이미지 업로드 시 기존 글의 이미지를 모두 삭제 후 업로드 하는 방식으로 해결
2. CORS 에러
→ 브라우저가 로컬 캐시를 사용하고 있어서 CORS에러가 나고 있음을 확인하였고, 이 부분을 해결하기 위해 이미지 URL로 get 요청 시 headers에 no-cache 설정을 추가하여 해결

[ CORS 에러 해결 과정 ]

1. S3 CORS 정책 설정
→ S3의 경우 요청 헤더에 Origin이 없을 경우 CORS 응답헤더를 전달하지 않음
2. Origin 헤더를 직접 추가하여 요청
→ 브라우저가 로컬 캐시를 사용하고 있어 CORS 에러가 지속됨을 확인
3. 이미지 URL로 get 요청 시 headers에 no-cache 설정을 추가

```
const config = {
        headers: {
          'Content-Type': 'multipart/form-data',
          'Cache-Control': 'no-cache',
        },
        responseType: 'blob',
      };
```

<br>

</details>


<details>
  <summary> <b>로그인 상태 유지 - 브라우저에 재 접속 시 Recoil 로그인 전역 상태 초기화 문제</b> </summary>
    
<br>

`문제 상황` 

저희 서비스는 사용자의 번거로움을 줄이기 위해 이미 로그인한 사용자라면, 리프레쉬 토큰 만료 전 까지는 브라우저 종료 후 다시 들어와도 로그인 한 상태를 유지해야 합니다. 문제는 Recoil 전역 상태로 토큰을 확인해 로그인 여부를 관리하였는데 브라우저가 실행되면 항상 초기값으로 초기화되기 때문에 Recoil에서 관리하는 로그인 상태의 초기값이 false일 경우 브라우저에서 재 접속 시 초기화 되어 다시 로그인을 해야 하는 상황이 발생했습니다.

`해결 방안` 

1. 앱이 처음 mount 되자마자 useEffect를 사용해 토큰의 여부를 확인하여 로그인 상태를 업데이트 
2. 로그인 전역 상태의 초기값을 아예 토큰 여부를 확인한 isToken 변수로 설정

`의견 조율` 

usEffect를 사용하여 앱이 처음 mount 시 로그인 여부를 업데이트 시키게 되면, 처음 로드됐을 때 외에 새로고침 등 상태값이 초기화 되는 상황 마다 업데이트가 되도록 따로 설정해주어야 합니다. 상태값이 초기값으로 초기화될 때 아예 토큰 여부를 확인한 결과값으로 초기화되게 하면 초기화 되는 모든 상황에서도 항상 토큰여부를 확인하여 결과값으로 로그인 여부를 파악하고 유지할 수 있다고 판단하였습니다.

`의견 결정`

상태의 초기값을 isToken의 토큰 여부를 확인한 결과값으로 초기화되게 하여 전역 상태를 잃는 모든 상황에서도 로그인 여부를 확인하고 유지할 수 있도록 하였습니다.


<br>

</details>


<details>
  <summary> <b>이메일 인증 코드, 리프레시 토큰 저장 장소 변경</b> </summary>
    
<br>

 `개선 전`
 
 
 이메일 인증 코드와 리프레쉬 토큰은 RDS에 MySQL DB를 연결하여 저장하고 관리하였습니다. 하지만 이로 인해, 간단한 조회 및 인증 과정에 사용하기 위해 매번 SQL 쿼리를 통해 DB에 접근해야하는 불편함이 있었습니다. 
 

 `해결 방법`
 
 
 이메일 인증 코드와 Refresh Token은 비교적 일시적인 데이터로 데이터의 지속성 보다는 주로 빠른 접근과 만료 처리를 용이하게 하는 효율성이 중요하였습니다. 그래서 메모리에 데이터를 저장하여 빠른 접근, key- value 쌍의 구조로 단순한 데이터 구조를 편하게 관리할 수 있고, 만료 시간을 설정할 수 있는 redis로 저장 장소를 변경하였습니다. 
 

 `개선 후 결과`
 
 
 예를 들어, 이메일 인증 요청시 "SETEX" "[email_verif_codekjs3@naver.com](mailto:email_verif_codekjs3@naver.com)" "180" "2g88K9jn"라고 서버에 저장이 되었습니다.  만료 시간은 3분으로 설정하였습니다.  
 
 사용자가 인증 코드 입력하여 인증 완료 시 인증된 이메일로 "SETEX" "[email_verifiedkjs3@naver.com](mailto:email_verifiedkjs3@naver.com)" "180" "true"로 설정하고, 데이터가 삭제되도록 설정하였습니다. 
 
 ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8689cd33-f1d0-4a41-a578-0ad64888c617/Untitled.png)
 
 또한 사용자가 로그인 시 Refresh token 저장하도록 하였습니다. 


<br>

</details>




